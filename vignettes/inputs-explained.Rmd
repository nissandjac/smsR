---
title: "smsR: Inputs & Functions Explained"
author: "smsR team"
date: "`r format(Sys.Date())`"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{Inputs & Functions Explained}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r pkg-setup, include=FALSE}
# Load smsR if available; set a flag we can reuse in chunk options
has_smsR <- requireNamespace("smsR", quietly = TRUE)
if (has_smsR) library(smsR)
```


## Purpose

This vignette documents the **core functions** and the **structure of inputs** for `smsR`.  
Use it as a reference when wiring your own datasets and when interpreting outputs.

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment  = "#>",
  dpi      = 150,
  fig.width = 6.8,
  fig.height = 4.2,
  message  = FALSE,
  warning  = FALSE
)
```

## Core workflow at a glance

1. **`get_TMB_parameters()`** – Create the TMB data/input list (seasons, ages, indices, SD groupings, likelihood weights).  
2. **`getParms()`** – Produce a matching **initial parameter vector**.  
3. **`runAssessment()`** – Fit the seasonal assessment (TMB + optimizer).  
4. **`plot()`** – Summaries: **SSB**, **Fbar**, **Recruitment**, **Catch**.  
5. **`mohns_rho()`** – Retrospective peels + **Mohn’s rho**.

---

## Input data objects (using `sandeel_1r`)

Below is the expected structure using the packaged dataset.  

```{r}
# Inspect the top-level object
# str(sandeel_1r, max.level = 1)
```

### `lhs` list

Contains **life-history and state variables** per season/age/year:

- **M**: natural mortality  
- **mat**: maturity ogive  
- **west**: weight-at-stock  
- **weca**: weight-at-catch

```{r}
# lapply(sandeel_1r$lhs, function(x) str(x, max.level = 1))
```

### `survey` list

Survey observations (indices, ages by seasons):

```{r}
# lapply(sandeel_1r$survey, function(x) str(x, max.level = 1))
```

### `Catch` list

Catch observations by season/age:

```{r}
# lapply(sandeel_1r$Catch, function(x) str(x, max.level = 1))
```

### `effort` data frame

Fishing effort time series (by year/season, as applicable):

```{r}
# str(sandeel_1r$effort)
```

### `nocatch` metadata

Seasons where **F is not calculated**:

```{r}
# str(sandeel_1r$nocatch)
```

---

## Building the TMB input list

Key arguments to `get_TMB_parameters()` (abbreviated list):

- **`mtrx`**: the `lhs` list (M, mat, west, weca)  
- **`Surveyobs` / `Catchobs`**: lists of survey/catch observations  
- **`years`**: numeric vector (first:last)  
- **`nseason`**: number of within-year seasons (e.g. 2)  
- **`ages`**: integer vector of modeled ages (e.g. 0:4)  
- **`recseason`**: season index where **recruitment** occurs  
- **`CminageSeason`**: minimum age per season for catch likelihood  
- **`Fmaxage`**: maximum age included in fishing mortality calc  
- **`Qminage`, `Qmaxage`**: survey selectivity age bounds per index  
- **`Fbarage`**: low/high ages for **Fbar**  
- **`effort`**: optional effort time series  
- **`blocks`**: breakpoints for piecewise parameters (e.g., selectivity)  
- **`surveyStart`, `surveyEnd`, `surveySeason`**: timing of surveys  
- **`surveySD`, `catchSD`**: SD groupings (lists of age bounds per season/index)  
- **`estSD`**: which SDs to estimate (survey, catch, SRR)  
- **`beta`**: breakpoint for recruitment (e.g., hockey-stick SRR)  
- **`nllfactor`**: relative likelihood weights (survey, catch, SRR)

Example (copied from the main vignette):

```{r}
# df.tmb <- get_TMB_parameters(
#   mtrx          = sandeel_1r$lhs,
#   Surveyobs     = sandeel_1r$survey,
#   Catchobs      = sandeel_1r$Catch,
#   years         = 1983:2021,
#   nseason       = 2,
#   useEffort     = TRUE,
#   ages          = 0:4,
#   recseason     = 2,
#   CminageSeason = c(1, 1),
#   Fmaxage       = 3,
#   Qminage       = c(0, 1),
#   Qmaxage       = c(1, 3),
#   Fbarage       = c(1, 2),
#   effort        = sandeel_1r$effort,
#   blocks        = c(1983, 1999),
#   nocatch       = sandeel_1r$nocatch,
#   surveyStart   = c(0.75, 0),
#   surveyEnd     = c(1, 0),
#   surveySeason  = c(2, 1),
#   surveySD      = list(c(0, 1), c(1, 2)),
#   catchSD       = list(c(1, 3), c(1, 3)),
#   estSD         = c(0, 2, 0),
#   beta          = 105809,
#   nllfactor     = c(1, 1, 0.05)
# )
```
---

## Process error options: `randomR`, `randomF`, and `randomM`

This section explains the switches that control **process error** in `smsR`.  
They decide whether key state variables include **random effects** (year/age/season deviations) around their mean dynamics.

### `randomR` — recruitment deviations
- **What it does**: Adds stochastic deviations (typically log-scale) around the stock–recruit mean, with variance \( \sigma_R^2 \) and year (and optionally season) effects \( \varepsilon_{R,y} \).
- **Why use**: Recruitment is highly variable; process error improves realism and short-term fit.
- **Watch**: Larger uncertainty in recruitment/early SSB; check retrospectives.

### `randomF` — fishing-mortality deviations
- **What it does**: Lets \(F\) depart from the deterministic structure (selectivity, blocks, and optionally effort), using variance \( \sigma_F^2 \) and deviations \( \varepsilon_{F,y,a,s} \).
- **Why use**: Captures unmodelled changes in exploitation/implementation.
- **Watch**: Uncertainty in F and derived quantities; inspect fit to CAA/indices and retrospectives.

### `randomM` — natural mortality deviations *(new option)*
- **What it does**: Allows **natural mortality \(M\)** to vary stochastically around its baseline schedule (age/season/year), via random effects with variance \( \sigma_M^2 \) and deviations \( \varepsilon_{M,y,a,s} \) (often on the log-scale to keep \(M>0\)).
- **Why/when to use**: When there is evidence that \(M\) is **time-varying** (e.g., changing predation pressure, temperature-linked mortality, disease) and static \(M\) biases residuals or trends.
- **Interactions & caveats**:
  - **Identifiability**: \(M\) can trade off with \(F\) and survey catchability/selection. Use **informative priors/penalties**, **bounds**, or **blocks** to stabilize.
  - **Confounding**: With `randomF = TRUE`, be extra cautious; inspect parameter correlations and the Hessian.
  - **Data support**: Independent information (predator indices, tagging, external \(M\) priors) is valuable.
- **Diagnostics**:
  - Check estimated \( \sigma_M \), the pattern of \( \varepsilon_{M,\cdot} \), and whether they’re biologically plausible.
  - Monitor correlations with \(F\), changes in objective value vs added variance, and **retrospectives**.

---

### Typical configurations (rules of thumb)

- **Conservative**: `randomR = TRUE`, `randomF = FALSE`, `randomM = FALSE`  
  (Capture R variability; keep F/M closer to baseline.)
- **Flexible**: `randomR = TRUE`, `randomF = TRUE`, `randomM = TRUE`  
  (Most flexible; only if data are strong and diagnostics look clean.)
- **Sensitivity baselines**: toggle one switch at a time to understand impacts.

---

### How to set these in your workflow

Depending on your version, the switches are either **arguments** to `get_TMB_parameters()` or **elements** on the returned input list.

```{r set-switches, eval=has_smsR, message=FALSE, warning=FALSE}
# As arguments (if supported in your version):
df.tmb <- smsR::get_TMB_parameters(
  mtrx          = sandeel_1r$lhs,
  Surveyobs     = sandeel_1r$survey,
  Catchobs      = sandeel_1r$Catch,
  years         = 1983:2021,
  nseason       = 2,
  useEffort     = TRUE,
  ages          = 0:4,
  recseason     = 2,
  CminageSeason = c(1, 1),
  Fmaxage       = 3,
  Qminage       = c(0, 1),
  Qmaxage       = c(1, 3),
  Fbarage       = c(1, 2),
  effort        = sandeel_1r$effort,
  blocks        = c(1983, 1999),
  nocatch       = sandeel_1r$nocatch,
  surveyStart   = c(0.75, 0),
  surveyEnd     = c(1, 0),
  surveySeason  = c(2, 1),
  surveySD      = list(c(0, 1), c(1, 2)),
  catchSD       = list(c(1, 3), c(1, 3)),
  estSD         = c(0, 2, 0),
  beta          = 105809,
  nllfactor     = c(1, 1, 0.05),
  randomR       = TRUE,
  randomF       = FALSE,
  randomM       = TRUE     # <— allow process error on natural mortality
)

# Or, if exposed on the input list instead:
# df.tmb$randomR <- TRUE
# df.tmb$randomF <- FALSE
# df.tmb$randomM <- TRUE

# IMPORTANT: rebuild starting parameters whenever structure changes
parms <- smsR::getParms(df.tmb)
fit   <- smsR::runAssessment(df.tmb, parms)
```


---

### Quick three-way comparison template

```{r compare-switches, eval=FALSE}
configs <- list(
  base    = list(randomR = TRUE,  randomF = FALSE, randomM = FALSE),
  randM   = list(randomR = TRUE,  randomF = FALSE, randomM = TRUE),
  randFM  = list(randomR = TRUE,  randomF = TRUE,  randomM = TRUE)
)

fits <- lapply(configs, function(cfg) {
  df2 <- smsR::get_TMB_parameters(
    mtrx = sandeel_1r$lhs, Surveyobs = sandeel_1r$survey, Catchobs = sandeel_1r$Catch,
    years = 1983:2021, nseason = 2, useEffort = TRUE, ages = 0:4, recseason = 2,
    CminageSeason = c(1, 1), Fmaxage = 3, Qminage = c(0, 1), Qmaxage = c(1, 3),
    Fbarage = c(1, 2), effort = sandeel_1r$effort, blocks = c(1983, 1999),
    nocatch = sandeel_1r$nocatch, surveyStart = c(0.75, 0), surveyEnd = c(1, 0),
    surveySeason = c(2, 1), surveySD = list(c(0, 1), c(1, 2)),
    catchSD = list(c(1, 3), c(1, 3)), estSD = c(0, 2, 0), beta = 105809,
    nllfactor = c(1, 1, 0.05),
    randomR = cfg$randomR, randomF = cfg$randomF, randomM = cfg$randomM
  )
  pr <- smsR::getParms(df2)
  try(smsR::runAssessment(df2, pr), silent = TRUE)
})

# Example comparisons (uncomment to use interactively)
# sapply(fits, function(f) if (!inherits(f, "try-error")) f$opt$objective)
# lapply(fits, function(f) if (!inherits(f, "try-error")) smsR::mohns_rho(df2, peels=3, parms=pr, plotfigure=FALSE))
```

---

## From inputs to fit

```{r}
# parms <- getParms(df.tmb)
# fit   <- runAssessment(df.tmb, parms)  # heavy; run in the getting-started vignette
```

### Outputs you can expect

Typical components (names may evolve with package updates):

- **`ts`**: time series (SSB, Fbar, recruitment, catches)  
- **`residuals`**: per-observation residuals (survey/catch)  
- **`opt`**: optimizer status (convergence code, value)  
- **`gradient`**: gradient diagnostics  
- **`plots`**: (if you store or return plot objects)  

```{r}
# Example accessors (pseudo):
# head(fit$ts)
# summary(fit$opt)
# p <- plot(fit, printFig = FALSE); p$ssb
```

---

## Retrospectives

```{r}
# mr <- mohns_rho(df.tmb, peels = 5, parms = parms, plotfigure = FALSE)
# mr$p1()  # core retrospective plot
# mr$summary  # if provided
```

---

## Cheatsheet (key functions)

- `get_TMB_parameters()` – build inputs  
- `getParms()` – initial parameters  
- `runAssessment()` – fit model  
- `plot()` – overview plots  
- `mohns_rho()` – retrospective analysis

---

## Function index (auto-generated from Rd docs)

```{r function-index-helpers, include=FALSE}
# Build an alias -> title table from the package's Rd docs, but
# hide helpers/operators like the pipe and 'dummy' from the final index.

make_rd_index <- function(pkg = "smsR",
                          exclude = c("%>%", "|>", "dummy")) {

  # Try to read installed Rd objects
  rd_list <- try(tools::Rd_db(pkg), silent = TRUE)
  if (inherits(rd_list, "try-error") || is.null(rd_list)) {
    return(data.frame(alias = character(), title = character()))
  }

  RdTags <- getFromNamespace("RdTags", "tools")

  rows <- lapply(rd_list, function(rd) {
    tags <- RdTags(rd)

    # Title
    title_nodes <- rd[tags == "\\title"]
    ttl <- paste0(
      unlist(lapply(title_nodes, function(x) paste(as.character(x), collapse = ""))),
      collapse = " "
    )
    if (!nzchar(ttl)) ttl <- ""

    # Aliases (often function names)
    alias_nodes <- rd[tags == "\\alias"]
    aliases <- unlist(lapply(alias_nodes, function(x) paste(as.character(x), collapse = "")), use.names = FALSE)
    if (length(aliases) == 0) aliases <- NA_character_

    data.frame(alias = aliases, title = ttl, stringsAsFactors = FALSE)
  })

  out <- do.call(rbind, rows)
  # Basic cleanup
  out <- out[!duplicated(out$alias) & !is.na(out$alias) & nzchar(out$alias), , drop = FALSE]

  # If the package namespace is available, keep ONLY exported, callable functions
  ns <- try(getNamespace(pkg), silent = TRUE)
  if (!inherits(ns, "try-error")) {
    exps <- try(getNamespaceExports(pkg), silent = TRUE)
    if (!inherits(exps, "try-error")) {
      out <- out[out$alias %in% exps, , drop = FALSE]
    }
    is_fun <- vapply(out$alias, function(a) {
      exists(a, envir = ns, inherits = FALSE) && is.function(get(a, envir = ns))
    }, logical(1))
    out <- out[is_fun, , drop = FALSE]
  }

  # Drop operators and explicitly excluded names
  out <- out[!grepl("%|\\|>", out$alias), , drop = FALSE]                   # operators like %>% or |>
  out <- out[!(tolower(out$alias) %in% tolower(exclude)), , drop = FALSE]   # explicit blacklist

  # Optional: drop dot-prefixed internals (uncomment if desired)
  # out <- out[!grepl("^\\.", out$alias), , drop = FALSE]

  # Sort nicely
  out <- out[order(tolower(out$alias)), , drop = FALSE]
  rownames(out) <- NULL
  out
}

# Build the index quietly for use in the next chunk
rd_index <- try(make_rd_index("smsR"), silent = TRUE)
```

```{r function-index-table, echo=FALSE, message=FALSE, warning=FALSE, error=FALSE}
if (!inherits(rd_index, "try-error") && is.data.frame(rd_index) && nrow(rd_index) > 0) {
  knitr::kable(rd_index, caption = "smsR function/topic index (from Rd titles)")
} else {
  cat("*(Function index unavailable at build time — ensure the package is installed and Rd files exist via `devtools::document()`.)*")
}
```

---

## Reproducibility

```{r}
sessionInfo()
```
